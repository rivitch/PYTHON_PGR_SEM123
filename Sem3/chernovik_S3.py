# -*- coding: utf-8 -*-
# В большой текстовой строке подсчитать количество встречаемых 
# слов и вернуть 10 самых частых. Не учитывать знаки препинания 
# и регистр символов. За основу возьмите любую статью 
# из википедии или из документации к языку
#------
# -*- coding: utf-8 -*-
# В большой текстовой строке подсчитать количество встречаемых 
# слов и вернуть 10 самых частых. Не учитывать знаки препинания 
# и регистр символов. За основу возьмите любую статью 
# из википедии или из документации к языку
import os, shutil
from pprint import pp
# _inp1 = 'Sem3/file.txt'
_inp1 = "Синтаксис и семантика. Несмотря на то, что одним из заявленных принципов дизайна Python является принцип наименьшего удивления, критики отмечают целый ряд архитектурных решений, которые могут вводить в заблуждение или вызывать недоумение у программистов, привыкших к другим распространённым языкам. В их числе: Отличие в принципе работы оператора присвоения по сравнению со статически-типизированными языками. В Python при присвоении значения копируется ссылка на объект, а не значение. При работе с простыми неизменяемыми типами возникает ощущение изменения значения переменной при присваивании ей значения, однако фактически присваивается ссылка на другое значение, например, при увеличении значения переменной типа int на 1 меняется ссылка, а не увеличивается значение по ссылке. Однако при работе с изменяемыми типами их содержимое можно менять по ссылке, поэтому при присвоении одной переменной ссылки на другую и последующем изменении значения в одной из двух переменных оно изменится в обеих переменных, что хорошо заметно при работе со списками. При этом кортежи хоть и являются неизменяемыми, но могут хранить ссылки на изменяемые объекты, поэтому по факту кортежи тоже можно менять; Отличие в поведении на некоторых типах «сокращённых» операторов, таких как += и их развёрнутой записи, хотя в большинстве языков «сокращённый» вариант — это просто краткая запись полного, и семантически они абсолютно эквивалентны. Жёсткая трактовка лексической области видимости, подобная используемой в JavaScript: даже если переменная получает значение в последней строке функции, её областью видимости является вся функция.Путаница между полями класса и полями объекта: текущее значение поля класса инициализирует одноимённое поле объекта, но не при создании объекта, а при первой записи значения в данное поле. Иногда сохранение связи между полем объекта и класса до первой перезаписи может стать причиной неожиданного эффекта: если в программе меняется значение поля класса, то все объекты, одноимённые поля которых ещё не перезаписаны, окажутся неявно изменены. Интуитивно трудно предсказуемое поведение параметров со значением-объектом по умолчанию. Если в качестве инициализатора для параметра по умолчанию указать конструктор объекта, это приведёт к созданию статического объекта, ссылка на который и будет передаваться по умолчанию в каждый вызов. Это может повлечь трудно уловимые ошибки."
# data = open("Sem3/file.txt", encoding="UTF-8")
# for line in data:
#     print(line)
# data.close()
# print(data)
#_inp1 = open("Sem3/file.txt", encoding="UTF-8")

#_inp2 = data.lower()
_inp2 = _inp1.lower()
#_inp1.close()
_list2 = ",!?."
for i in _list2:
    _inp2 = _inp2.replace(i, "")
_list1 = _inp2.split() 
print(_list1)
#print(_list1.count("qwerte"))
res = []
for i in _list1:
    if [[_list1.count(i)],[i]] not in res:
        res.append([_list1.count(i),i])
    print(res)
    # if _list1.count(i) >9:
    #     res.append(i)
    #res = list(set(res))

print("-----------",res)


#---------
# import os, shutil
# from pprint import pp




# _inp1 = 'Sem3/file.txt'
# # this_dir = os.path.dirname(os.path.abspath(__file__))
# # file = os.path.join(this_dir, _inp1)
# data = open(_inp1, 'r')
# for line in data:
#     print(line)
# data.close()


# _inp1 = "Синтаксис и семантика. Несмотря на то, что одним из заявленных принципов дизайна Python является принцип наименьшего удивления, критики отмечают целый ряд архитектурных решений, которые могут вводить в заблуждение или вызывать недоумение у программистов, привыкших к другим распространённым языкам. В их числе: Отличие в принципе работы оператора присвоения по сравнению со статически-типизированными языками. В Python при присвоении значения копируется ссылка на объект, а не значение. При работе с простыми неизменяемыми типами возникает ощущение изменения значения переменной при присваивании ей значения, однако фактически присваивается ссылка на другое значение, например, при увеличении значения переменной типа int на 1 меняется ссылка, а не увеличивается значение по ссылке. Однако при работе с изменяемыми типами их содержимое можно менять по ссылке, поэтому при присвоении одной переменной ссылки на другую и последующем изменении значения в одной из двух переменных оно изменится в обеих переменных, что хорошо заметно при работе со списками. При этом кортежи хоть и являются неизменяемыми, но могут хранить ссылки на изменяемые объекты, поэтому по факту кортежи тоже можно менять; Отличие в поведении на некоторых типах «сокращённых» операторов, таких как += и их развёрнутой записи, хотя в большинстве языков «сокращённый» вариант — это просто краткая запись полного, и семантически они абсолютно эквивалентны. Жёсткая трактовка лексической области видимости, подобная используемой в JavaScript: даже если переменная получает значение в последней строке функции, её областью видимости является вся функция.Путаница между полями класса и полями объекта: текущее значение поля класса инициализирует одноимённое поле объекта, но не при создании объекта, а при первой записи значения в данное поле. Иногда сохранение связи между полем объекта и класса до первой перезаписи может стать причиной неожиданного эффекта: если в программе меняется значение поля класса, то все объекты, одноимённые поля которых ещё не перезаписаны, окажутся неявно изменены. Интуитивно трудно предсказуемое поведение параметров со значением-объектом по умолчанию. Если в качестве инициализатора для параметра по умолчанию указать конструктор объекта, это приведёт к созданию статического объекта, ссылка на который и будет передаваться по умолчанию в каждый вызов. Это может повлечь трудно уловимые ошибки."

# _inp2 = _inp1.lower()
# _remove = ",!?.:;-=+"
# for smb in _remove:
#     _inp2 = _inp2.replace(smb, "")
# _list1 = _inp2.split() # досюда работает
# # print(_list1)
# # print(_list1.count(_list1[1]))
# x = sorted(list(set(_list1)))
# print(sorted(list(set(_list1))))
# print("123===",_list1[38], _list1.count("в"))
# res = []
# res1 =[]
# #print(_list1[0], x[0])
# for i in _list1:
#     if _list1.count(i) >=10:
#         res.append(i)
# #print("set--- ", set(res))
# for i in _list1:
#     res1.append(_list1.count(i))
# for spam, eggs in enumerate(_list1, res):
#     print(f"{spam}.{eggs : >10}")
#     if _list1.count(i) >5:
#         res.append(i)
#         res = list(set(res))
# print("0---", res)
# print("1---", res1)




# _inp2 = _inp1.lower()
# # _list2 = _inp.split()
# # print(_inp,"\n", _list2)
# symbols_to_remove = ",!?."
# for symbol in symbols_to_remove:
#     _inp2 = _inp2.replace(symbol, "")
# _list1 = _inp2.split() # досюда работает
# print(_list1)
# print(_list1.count("qwerte"))
# res = []
# for i in _list1:
#     if _list1.count(i) >1:
#         res.append(i)
#         res = list(set(res))




# for i in _list1:
#     res.append(_list1.count(i))
# for spam, eggs in enumerate(res, 1):
#         #if spam not in (x, y, z):
#         print(f"{spam}. {eggs : >2}")    
#res.append(_list1.count("qwerte"))
# print("1", res)
# z=0 
# 
# for i in _list1:
#     print(i)
#     for j in range(len(_list1)):
#         #print(j, res)
#         res = []
#         _list1.count(i)
#         res[j] = z
#         print(i, j)
#         #pass
    #pass    
# print(res)
#--------
# import os, shutil
# #os.getcwd()

# _inp1 = ''Sem3\file.txt''
# # this_dir = os.path.dirname(os.path.abspath(__file__))
# # file = os.path.join(this_dir, _inp1)
# data = open(_inp1, 'r')
# for line in data:
#     print(line)
# data.close()